# 算法基础实验3报告

***

梁峻滔 PB19051175

***

[toc]

## 3-1 领奖台数

### 第一种思想

按 j , i, k 的顺序枚举满足 i < j < k 且 a[j] > a[i] > a[k] 的三元组数, 时间复杂度为$O(n^3)$. 超时.

### 第一种优化

使用分治策略, 先将原数组分解为左右两半, 先分别求解两个子数组的tuple数, 并为每个元素维护三个信息: 该元素在原数组中的位置, 在该元素所在子数组中、在原数组中的位置在该元素右边且小于该元素的元素个数, 以及在该元素所在子数组中、在原数组中的位置在该元素左边且大于该元素的元素个数. 这样在合并(并且排序)时就可以根据这些信息更新总的tuple数.

以上维护的三种信息采用以原数组元素值为key的哈希表(C++ STL中的unordered_map)维护.

合并时采用MergeSort的过程, 在排序的过程中更新信息. 按 tuple 中 i, j, k 来自两个子数组的情况分两种情况: (1) i, j 来自左子数组, k 来自右子数组; (2) i 来自左子数组, j 和 k 来自右子数组. 其中第(2)中情况需要剔除一些与(1)对称的情况.

结果还是超时.

### 第二种优化

采用另一种不会产生冲突的哈希: 先将元素映射到它在原数组的位置, 将该位置作为上面提到的两种信息(即除元素在原数组中的位置的其他两种)的索引. 后面三个测试点从超时变成WA了.

### 第三种"优化"

将除了`int main()`外的所有 int 全部替换成 long long, Accepted.

## 3-2 最短达标区间

设一个数组P, P[i]存放输入数组A的前 i 项和, 即
$$
P[i] = A[1]+A[2]+...+A[i]
$$
目标是找到一对x < y, 使得$P[y]-P[x] \geq K$且使得 $y-x$ 最小. 用一个min变量记录最小达标区间的长度. 使用一个双端队列Q, 按 i = 1, 2, 3, ... 遍历P[i], 考察P[i]时, 将队列Q中 $\geq$P[i] 的P[j] (一定会有j < i)全部从队尾出队, 然后不断将满足
$$
P[i]-Q[0] \geq K, Q[0]=P[l]
$$
的队头元素Q[0]从队头出队, 同时若有 $P[i]-Q[0] \leq min$ 就更新min. 直到 i = n.这时变量 min 所记录的就是所要求的最小达标区间长度.

计算数组P只需要遍历数组A, 之后每个P[i]最多入队和出队各一次, 算法遍历完P数组就结束, 因此时间复杂度是$O(n)$.

## 3-3 找零

设硬币集合为$a[1..n]$, 使用一个二维数组$dp$, $dp[i][j]$ 表示用前 i 种硬币, 即 $a[1..i]$ 凑出金额 j 的组合数, 这样状态转移方程就是
$$
dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]] + dp[i-1][j-2×a[i]] + ... + dp[i-1][j-k×a[i]] \quad (1)
$$
 其中 $k = j / a[i]$. 这样枚举 i 和 j 需要$O(n^2)$的时间, 加上计算$dp[i][j]$就需要$O(n^3)$的时间, 而且使用二维的 dp 数组会导致空间开销超过所给限制. 考虑优化.

* 时间复杂度优化: 观察得
    $$
    dp[i][j-a[i]] = dp[i-1][j-a[i]] + dp[i-1][j-2×a[i]] + ... + dp[i-1][j-k × a[i]] \quad (2)
    $$
    可以用该式替换(1)式中右边的第二项开始后面的部分, 因此有
    $$
    dp[i][j] = dp[i-1][j] + dp[i][j-a[i]] \quad (3)
    $$
    这样只需枚举 i 和 j, 时间复杂度降低为$O(n^2)$.

* 空间复杂度优化: 上面(3)式中实际上可以只使用一维的 dp 数组, 因此实际的迭代方程为
  $$
  dp[j] = dp[j] + dp[j-a[i]] \quad (4)
  $$
  因为在式子左边的 dp[j] 更新前, 式子右边的 dp[j] 实际上记录的是 dp\[i-1][j]. 而根据计算顺序, dp[j-a[i]] 记录的就是 dp\[i][j-a[i]].

本题还需要注意的一个地方是 dp[j] 更新过程中要对1000000007取余, 我一开始是在最后取余, 这样还是会导致Wrong Answer, 取余操作需要放到迭代过程中做, 因为可能在迭代过程中就已经超过了这个数. 

## 3-4 最大连续子方阵

使用一个二维数组S, 其中$S[i][j]=\sum_{i_1\leq i,j_1 \leq j}A[i_1][j_1]$. 实际计算 S\[i][j] 可以使用以下式子通过迭代计算在 $O(n^2)$ 内完成:
$$
S[i][j] = S[i-1][j]+S[i][j-1]-S[i-1][j-1]+A[i][j]
$$
使用一个变量 max_k 记录最大全为1的连续子方阵的阶.

遍历 i, j, k 来考察以 A\[i]\[j] 为右下角的 k 阶子方阵, 如果该 k 阶子方阵的元素全为1, 就根据 k 和 max_k 的关系来更新 max_k. 判断 k 阶子方阵的元素是否全为1可以用以下等式来判断:
$$
S[i][j]-S[i][j-k]-S[i-k][j]+S[i-k][j-k]=k^2
$$
如果上面等式成立, 就表示该 k 阶子方阵的元素全为1.

其中遍历 i, j, k 的过程中, 由于以 A\[i][j] 为右下角的子方阵的阶最大为 min(i, j), 所以可以剪掉 $i \leq max\_k$ 和 $j \leq max\_k$ 的情况. 对 k 的遍历也可以使用二分法在[max_k+1, min(i, j)]之间遍历. 这样算法的整体时间复杂度就是$O(n^2\ log \ n)$.
