# 实验2报告

***

梁峻滔 PB19051175

***

## 2-1 成绩单

### 1. 整体框架

* 使用大根堆存储`score`
* 使用哈希表来存储一个节点在大根堆中的下标
* 使用拉链法来处理哈希冲突

查询过程为先根据`name`使用BKDRHash映射后的值到哈希表中取出该学生成绩节点在大根堆中的下标, 再通过该下标访问大根堆获得成绩.

插入/删除的过程, 是在堆的插入/删除的基础上, 加入维护堆下标哈希表的过程.

查询最高分的元素时, 从根节点开始, 使用一个先进先出队列, 将一个最高分节点出队时计数加一, 如果刚出队的最高分节点的孩子节点也是最高分, 就将其入队, 直到队列为空就可以获得所有最高分节点. 然后可以再将其按`name`用基数排序就可以实现$O(k)$按字典序输出.

### 2. 一些踩过的坑

关于指针使用的各种细节问题.

## 2-2 红黑树

### 1. 整体框架

在普通红黑树的基础上为每个节点添加一个 `size` 域, 表示以该节点为根的子树中的节点数. 在插入和删除时维护该域.

查询 [A, ∞] 区间的最小元素时, 先找到树中最大的节点, 然后从根节点开始, 不断地找大于等于A的元素, 在查找过程中记录已经遍历过的最小的大于等于A的元素min_value, 从树根遍历到 `NIL`节点后, 最后记录的min_value即为所求的最小元素.

查询 [L, R] 区间的元素数时, 可以先查询 [L, ∞] 的最小元素和 [R, ∞] 的最小元素, 求出它们在树中元素的顺序, 再根据树中有无值等于R的节点调整后相减即可.

### 2. 一些踩过的主要的大坑

`NIL`节点的作用不能用`nullptr`代替.

## 2-3 最长递增子序列

算法思想:

用一个数组final_of_leni记录不同长度的递增子序列中最有"潜力"子序列的最后一个元素.

考察a[i]元素时, 二分查找第一个不小于a[i]的final_of_leni[j], 有可能全部都小于a[i].

将a[i]作为final_of_leni[j+1]对应子序列的最后一个元素, 得到一个新的长度为j的递增子序列newj.

newj的最后一个元素是a[i], 比final_of_leni[j]小, 因此newj比原来的长度为j的子序列更有可能得到"延长".

遍历完a[i]后取max_len = argmax{final_of_len[i]!=-1}.